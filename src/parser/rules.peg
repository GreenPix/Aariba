use super::expressions::{Node,FunctionKind,BinOp};
use super::expressions;
use expressions::*;

use rules::{Variable,RulesEvaluator};

#[pub]
expression -> ExpressionEvaluator
	= tree:expression_tree { expressions::convert(tree) }
#[pub]
expression_tree -> Node
	= spaces node:prio1 spaces {node}
prio1 -> Node
	= l:prio2 r:prio2_right* { expressions::combine(l,r) }
prio2 -> Node
	= l:prio3 r:prio3_right* { expressions::combine(l,r) }
prio3 -> Node
	= l:prio4 r:prio4_right* { expressions::combine(l,r) }
prio4 -> Node
	= "(" v:prio1 ")" { v }
        / number
        / function
        / variable
number -> Node
	= [-+]?[0-9]+("."[0-9]+)?([eE][-+]?[0-9]+)? {
                let number: f64 = match_str.parse().unwrap();
                Node::F64(number)
        }

function -> Node
        = name:function_name spaces "("args:expression_tree ** "," ")" {
                Node::Function {
                        function: name,
                        operands: args,
                }
        }

function_name -> FunctionKind
        = "rand" { FunctionKind::Rand }
        / "min" { FunctionKind::Min }
        / "max" { FunctionKind::Max }
        / "sin" { FunctionKind::Sin }
        / "cos" { FunctionKind::Cos }

prio1_operator -> BinOp
        = spaces "+" spaces { BinOp::Plus }
        / spaces "-" spaces { BinOp::Minus }

prio2_right -> (BinOp,Node)
        = op:prio1_operator r:prio2 { (op,r) }

prio2_operator -> BinOp
        = spaces "*" spaces { BinOp::Multiply }
        / spaces "/" spaces { BinOp::Divide }

prio3_right -> (BinOp,Node)
        = op:prio2_operator r:prio3 { (op,r) }

prio3_operator -> BinOp
        = spaces "^" spaces { BinOp::Pow }

prio4_right -> (BinOp,Node)
        = op:prio3_operator r:prio4 { (op,r) }

variable -> Node
        = l:"$"? name:ident { Node::Variable {local: !l.is_some(), name: name.to_string()} }

ident -> String
        = [a-zA-Z]+ { match_str.to_string() }

space = [ \t\n]
spaces = [ \t\n]*

#[pub]
rules_list -> Vec<(Variable,ExpressionEvaluator)>
        = assignment*

assignment -> (Variable,ExpressionEvaluator)
        = global:"$"? name:ident spaces "=" spaces expr:expression ";" spaces {
            (Variable::new(global.is_none(), name), expr)
        }

#[pub]
rules_evaluator -> RulesEvaluator
        = l:rules_list { RulesEvaluator::new(l) }
