use super::expressions::{Node};
use super::expressions;
use expressions::*;

use rules::{Variable,RulesEvaluator};

#[pub]
expression -> ExpressionEvaluator
	= tree:expression_tree { expressions::convert(tree) }
#[pub]
expression_tree -> Node
	= prio1
prio1 -> Node
	= l:prio2 r:prio2_right* { expressions::combine(l,r) }
prio2 -> Node
	= l:prio3 r:prio3_right* { expressions::combine(l,r) }
prio3 -> Node
	= l:prio4 r:prio4_right* { expressions::combine(l,r) }
prio4 -> Node
	= "(" v:prio1 ")" { v }
        / number
        / variable
number -> Node
	= [0-9]+ { 
                let number: i64 = match_str.parse().unwrap();
                Node::I64(number)
        }

prio1_operator -> Operator
        = spaces "+" spaces { Operator::Plus }
        / spaces "-" spaces { Operator::Minus }

prio2_right -> (Operator,Node)
        = op:prio1_operator r:prio2 { (op,r) }

prio2_operator -> Operator
        = spaces "*" spaces { Operator::Multiply }
        / spaces "/" spaces { Operator::Divide }

prio3_right -> (Operator,Node)
        = op:prio2_operator r:prio3 { (op,r) }

prio3_operator -> Operator
        = spaces "^" spaces { Operator::Pow }

prio4_right -> (Operator,Node)
        = op:prio3_operator r:prio4 { (op,r) }

variable -> Node
        = l:"$"? name:ident { Node::Variable {local: !l.is_some(), name: name.to_string()} }

ident -> String
        = [a-zA-Z]+ { match_str.to_string() }

space = [ \t\n]
spaces = [ \t\n]*

#[pub]
rules_list -> Vec<(Variable,ExpressionEvaluator)>
        = assignment*

assignment -> (Variable,ExpressionEvaluator)
        = global:"$"? name:ident spaces "=" spaces expr:expression ";" {
            (Variable::new(global.is_none(), name), expr)
        }

#[pub]
rules_evaluator -> RulesEvaluator
        = l:rules_list { RulesEvaluator::new(l) }
