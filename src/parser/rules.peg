use super::expressions::{Node,FunctionKind,BinOp};
use super::expressions;
use expressions::*;

use rules::{Variable,RulesEvaluator,Instruction};

#[pub]
expression -> ExpressionEvaluator
	= tree:expression_tree { expressions::convert(tree) }
#[pub]
expression_tree -> Node
	= spaces node:prio1 spaces {node}
prio1 -> Node
	= l:prio2 r:prio2_right* { expressions::combine(l,r) }
prio2 -> Node
	= l:prio3 r:prio3_right* { expressions::combine(l,r) }
prio3 -> Node
	= l:prio4 r:prio4_right* { expressions::combine(l,r) }
prio4 -> Node
	= "(" v:prio1 ")" { v }
        / number
        / function
        / v:variable { v.into() }
number -> Node
	= [-+]?[0-9]+("."[0-9]+)?([eE][-+]?[0-9]+)? {
                let number: f64 = match_str.parse().unwrap();
                Node::F64(number)
        }

function -> Node
        = name:function_name spaces "("args:expression_tree ** "," ")" {
                Node::Function {
                        function: name,
                        operands: args,
                }
        }

function_name -> FunctionKind
        = "rand" { FunctionKind::Rand }
        / "min" { FunctionKind::Min }
        / "max" { FunctionKind::Max }
        / "sin" { FunctionKind::Sin }
        / "cos" { FunctionKind::Cos }

prio1_operator -> BinOp
        = spaces "+" spaces { BinOp::Plus }
        / spaces "-" spaces { BinOp::Minus }

prio2_right -> (BinOp,Node)
        = op:prio1_operator r:prio2 { (op,r) }

prio2_operator -> BinOp
        = spaces "*" spaces { BinOp::Multiply }
        / spaces "/" spaces { BinOp::Divide }

prio3_right -> (BinOp,Node)
        = op:prio2_operator r:prio3 { (op,r) }

prio3_operator -> BinOp
        = spaces "^" spaces { BinOp::Pow }

prio4_right -> (BinOp,Node)
        = op:prio3_operator r:prio4 { (op,r) }

variable -> Variable
        = l:"$"? name:ident { Variable {local: l.is_none(), name: name.to_string()} }

ident -> String
        = [a-zA-Z]+ { match_str.to_string() }

space = [ \t\n]
spaces = [ \t\n]*

#[pub]
rules_list -> Vec<Instruction>
        = instruction*

instruction -> Instruction
        = if
        / assignment

assignment -> Instruction
        = spaces variable:variable spaces "=" spaces expr:expression ";" spaces {
                Instruction::Assignment {
                        variable: variable,
                        expression: expr,
                }
        }

if -> Instruction
        = spaces "if" spaces variable:variable then:instruction_bloc else_branch:else_block?
        {
                Instruction::If {
                        condition: variable,
                        then: then,
                        else_branch: else_branch,
                }
        }

instruction_bloc -> RulesEvaluator
        =  spaces "{" spaces instructions:rules_evaluator spaces "}" spaces {
                instructions
        }

else_block -> RulesEvaluator
        = "else" block:instruction_bloc {
                block
        }

#[pub]
rules_evaluator -> RulesEvaluator
        = l:rules_list { RulesEvaluator::new(l) }
