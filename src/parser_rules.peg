use super::{Node};
use rules::*;

#[pub]
expression -> Node
	= prio1
prio1 -> Node
	= l:prio2 r:prio2_right* { super::combine(l,r) }
prio2 -> Node
	= l:prio3 r:prio3_right* { super::combine(l,r) }
prio3 -> Node
	= l:prio4 r:prio4_right* { super::combine(l,r) }
prio4 -> Node
	= "(" v:prio1 ")" { v }
        / number
        / variable
number -> Node
	= [0-9]+ { 
                let number: i64 = match_str.parse().unwrap();
                Node::I64(number)
        }

prio1_operator -> Operator
        = spaces "+" spaces { Operator::Plus }
        / spaces "-" spaces { Operator::Minus }

prio2_right -> (Operator,Node)
        = op:prio1_operator r:prio2 { (op,r) }

prio2_operator -> Operator
        = spaces "*" spaces { Operator::Multiply }
        / spaces "/" spaces { Operator::Divide }

prio3_right -> (Operator,Node)
        = op:prio2_operator r:prio3 { (op,r) }

prio3_operator -> Operator
        = spaces "^" spaces { Operator::Pow }

prio4_right -> (Operator,Node)
        = op:prio3_operator r:prio4 { (op,r) }

variable -> Node
        = [a-z]+ { Node::Variable(match_str.to_string()) }

space = [ \t\n]
spaces = [ \t\n]*

